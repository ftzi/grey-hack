/*
  Dashboard/companion program.
  Lists available tools and programs.
 */
#import Std from "lib/std"
#import Setup from "tools/setup"
#import Clean from "tools/clean"
#import Hack from "tools/hack"
#import XCrypto from "lib/xcrypto"

X = {}

// Predefined key mappings for known programs
X.predefinedKeys = {
    "FileExplorer": "F",
    "Terminal": "T",
    "Mail": "E",
    "Browser": "B",
    "Notepad": "N",
    "Settings": "S",
    "LogViewer": "L",
    "CodeEditor": "C",
    "ImageViewer": "I",
    "PDFReader": "P",
    "Map": "M",
    "Manual": "K",
    "ScanLan": "L",
    "HackShop": "H",
    "AdminMonitor": "A",
}

Decipher = {}
Decipher.run = function ()
  XCrypto.decipherTool()
end function

/*
  Returns the map of available tools keyed by their shortcut key.

  @return {map}
 */
X.getTools = function ()
  return {
    "1": {"name": "Hack", "module": Hack},
    "2": {"name": "Setup", "module": Setup},
    "3": {"name": "Security", "module": Security},
    "4": {"name": "Decipher", "module": Decipher},
    // "3": {"name": "Clean", "module": Clean},
  }
end function

/*
  @type Program
  @property {string} name
  @property {string} path
  @property {string|null} params
 */
Program = {}

/*
  Returns a map of executable files keyed by their shortcut key.
  Assigns predefined keys to known programs, sequential keys to others.

  @return {map<string, Program>} Map of key to program data (name, path, params)
 */
X.getPrograms = function ()
    // Collect all programs first
    programNames = []
    programData = {}

    usrBin = get_shell.host_computer.File("/usr/bin")
    if (usrBin != null) then
        for file in usrBin.get_files
            if (file.is_binary) then
                name = file.name.removeSuffix(".exe")
                programNames.push(name)
                programData[name] = {"path": file.path}
            end if
        end for
    end if

    // Add special programs
    programNames.push("HackShop")
    programData["HackShop"] = {"path": "/usr/bin/Browser.exe", "params": #envar HACKSHOP_IP}

    // Build key map
    keyToProgram = {}
    usedKeys = {}
    allKeys = "QWERTYUIOPASDFGHJKLZXCVBNM"
    nextKeyIndex = 0

    // First, assign predefined keys
    for programName in programNames
        if (X.predefinedKeys.hasIndex(programName)) then
            key = X.predefinedKeys[programName]
            data = programData[programName]
            data.name = programName
            keyToProgram[key] = data
            usedKeys[key] = true
        end if
    end for

    // Then, assign sequential keys to unmapped programs
    for programName in programNames
        hasKey = false
        for key in keyToProgram.indexes
            if (keyToProgram[key].name == programName) then
                hasKey = true
                break
            end if
        end for

        if (not hasKey) then
            // Find next available key
            while (nextKeyIndex < allKeys.len)
                key = allKeys[nextKeyIndex]
                nextKeyIndex = nextKeyIndex + 1
                if (not usedKeys.hasIndex(key)) then
                    data = programData[programName]
                    data.name = programName
                    keyToProgram[key] = data
                    usedKeys[key] = true
                    break
                end if
            end while
        end if
    end for

    return keyToProgram
end function

/*
  Prints the menu with tools and programs using column formatting.

  @param {map} tools - Map of key to tool data
  @param {map} programs - Map of key to program data
 */
X.printMenu = function (tools, programs)
    message = ""
    maxRows = 8

    // Convert tools map to sorted list by key
    toolsList = []
    for key in tools.indexes
        toolsList.push({"key": key, "name": tools[key].name})
    end for
    if (toolsList.len > 1) then toolsList.sort("key")

    // Convert programs map to sorted list by key
    programsList = []
    for key in programs.indexes
        programsList.push({"key": key, "name": programs[key].name})
    end for
    if (programsList.len > 1) then programsList.sort("key")

    // Split programs into columns of 8
    programColumns = []
    columnIndex = 0
    for i in range(0, programsList.len - 1)
        if (i % maxRows == 0) then
            programColumns.push([])
            columnIndex = programColumns.len - 1
        end if
        programColumns[columnIndex].push(programsList[i])
    end for

    // Build header row
    headers = ["Tools"]
    for i in range(0, programColumns.len - 1)
        headers.push("Programs")
    end for
    message = headers.join(" ").LF

    // Build data rows
    for rowIndex in range(0, maxRows - 1)
        row = []

        // Add tool to first column
        if (rowIndex < toolsList.len) then
            tool = toolsList[rowIndex]
            row.push(tool.key + ")" + Std.NBSP + tool.name + Std.NBSP)
        else
            row.push("-")
        end if

        // Add programs from each column
        for colIndex in range(0, programColumns.len - 1)
            col = programColumns[colIndex]
            if (rowIndex < col.len) then
                program = col[rowIndex]
                // Use ) for predefined programs, ] for dynamically assigned
                bracket = ")"
                if (not X.predefinedKeys.hasIndex(program.name)) then bracket = "]"
                row.push(program.key + bracket + Std.NBSP + program.name + Std.NBSP)
            else
                row.push("-")
            end if
        end for

        message = message + row.join(" ")
        if (rowIndex < maxRows - 1) then message = message.LF
    end for

    computer = get_shell.host_computer
    print("Hi, $. $. $ @ $".f(active_user, current_date, computer.public_ip, computer.local_ip).LF)
    print(format_columns(message).LF)
end function

/*
  Parses command line parameters.

  @return {map}
 */
X.parseParams = function ()
    result = {"autoRun": null}
    if (params == null or typeof(params) != "list" or params.len == 0) then return result

    for i in range(0, params.len - 1)
        if (params[i] == "-r" and i + 1 < params.len) then
            result.autoRun = params[i + 1]
        end if
    end for

    return result
end function

/*
  Main entry point. Lists tools and programs and handles user input.
 */
X.main = function ()
    // Parse parameters
    parsedParams = X.parseParams()

    // Auto-run tool if specified
    if (parsedParams.autoRun != null) then
        tools = X.getTools()
        tool = tools.get(parsedParams.autoRun)
        if (tool != null) then
            clear_screen()
            tool.module.run()
            return
        end if
    end if

    clear_screen()

    while (true)
        tools = X.getTools()
        programs = X.getPrograms()

        X.printMenu(tools, programs)

        choice = user_input("Press key to launch (or X to relaunch): ", false, true)

        if (choice.lower == "x") then
            get_shell.launch(launch_path, "")
            exit("")
        end if

        choice = choice.upper

        // Check if it's a tool (1-4) - launch in new terminal
        tool = tools.get(choice)
        if (tool != null) then
            get_shell.launch("/usr/bin/Terminal.exe", launch_path + " -r " + choice)
            clear_screen()
            continue
        end if

        // Check if it's a program
        program = programs.get(choice)
        if (program != null) then
            clear_screen()
            get_shell.launch(program.path, Std.elseDefault(program.get("params"), ""))
        end if
    end while
end function

X.main()
