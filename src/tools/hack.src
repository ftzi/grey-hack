/*
  Main hacking tool. Either runs remotely using an IP or locally for local exploits.
 */
#import Breachs from "../lib/breaches-ui"
#import Remote from "../lib/remote"
#import Lib from "../lib/lib"
#import LocalKv from "../lib/local-kv"

Hack = {}

/*
  Prompts for an IP address with options to use previous IP or local mode.

  @return {string|null} The IP address or null for local mode
 */
Hack.promptForIp = function()
    previousIp = LocalKv.hack.lastIp.get()

    prompt = "IP address (or L for local"
    if (previousIp) then
        prompt = prompt + ", Enter for previous: " + previousIp
    end if
    prompt = prompt + "): "

    while true
      input = user_input(prompt)
      input = input.trim()

      // Handle empty input - default to local
      if (input == "" and previousIp) then return previousIp

      // Handle local option
      if (input.upper == "L") then return null

      // Validate IP address
      if (is_valid_ip(input)) then
        LocalKv.hack.lastIp.set(input)
        return input
      end if

      // Invalid input - show error and prompt again
      print("Invalid IP address or option. Please try again.".error)
    end while
end function

/*
  Runs the hacking tool. Prompts for IP, port, and other parameters.
 */
Hack.run = function ()
  if not get_shell.host_computer.is_network_active then exit("No internet access.")

  ip = Hack.promptForIp()

  optArgs = ""
  port = 0
  // targetUser = "root"
	remote = null

  if (ip) then
    remote = Remote.New(ip)
    remote.print()

    optArgs = user_input("OptArgs (optional): ")

    // portInput = user_input("Port (default 0): ")
    // if (portInput) then port = portInput.to_int

    // userInput = user_input("Target user (default root): ")
    // if (userInput) then targetUser = userInput
  end if

  breaches = Breachs.New(ip)

	if (ip) then
    // /*
    //   Sorts remoteLibs to prioritize the one matching the specified optArgs.

    //   @param {remoteLib} a
    //   @param {remoteLib} b
    //   @return {number}
    //  */
    // sortRemoteLibs = function (a, b)
    //     if (a.optArgs == optArgs and b != optArgs) then return -1
    //     if (a.optArgs != optArgs and b == optArgs) then return 1
    // end function
    // remoteLibsPrioritized = .sort2(@sortRemoteLibs)

    for remoteLib in remote.remoteLibs
        breaches.scanAndExploit(remoteLib, optArgs)
    end for
	else
    localLibName = "init.so" // TODO cycle through them automatically if none is specified.
    // Should get their versions and prefer the ones we have addresses for.
		lib = Lib.metaxploit.load("/lib/"+localLibName)
    breaches.scanAndExploitLocal(lib, optArgs)
	end if

  breaches.print()
	breaches.handleInput(remote)
end function

module.exports = Hack
