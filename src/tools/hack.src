/*
  Main hacking tool. Either runs remotely using an IP or locally for local exploits.
 */
#import Breachs from "../lib/breaches-ui"
#import Remote from "../lib/remote"
#import Lib from "../lib/lib"
#import LocalKv from "../lib/local-kv"

Hack = {}

/*
  Prompts for an IP address with options to use previous IP or local mode.

  @return {string|null} The IP address or null for local mode
 */
Hack.promptForIp = function()
    previousIp = LocalKv.hack.lastIp.get()

    prompt = "IP address (or L for local"
    if (previousIp) then
        prompt = prompt + ", P for previous: " + previousIp
    end if
    prompt = prompt + "): "

    while true
        input = user_input(prompt)
        input = input.trim()

        // Handle empty input - default to local
        if (input == "") then return null

        // Handle local option
        if (input.upper == "L") then return null

        // Handle previous IP option
        if (input.upper == "P" and previousIp) then return previousIp

        // Validate IP address
        if (is_valid_ip(input)) then
            LocalKv.hack.lastIp.set(input)
            return input
        end if

        // Invalid input - show error and prompt again
        print("Invalid IP address or option. Please try again.".error)
    end while
end function

/*
  Runs the hacking tool. Prompts for IP, port, and other parameters.
 */
Hack.run = function ()
    if not get_shell.host_computer.is_network_active then exit("No internet access.")

    ip = Hack.promptForIp()

    lanIp = ""
    port = 0
    // targetUser = "root"
	remote = null

    if (ip) then
        remote = Remote.New(ip)
        remote.print()

        lanIp = user_input("LAN IP (optional): ")

        // portInput = user_input("Port (default 0): ")
        // if (portInput) then port = portInput.to_int

        // userInput = user_input("Target user (default root): ")
        // if (userInput) then targetUser = userInput
    end if

    breaches = Breachs.New(ip)

	if (ip) then
        /*
          Sorts remoteLibs to prioritize the one matching the specified lanIp.

          @param {remoteLib} a
          @param {remoteLib} b
          @return {number}
         */
        sortRemoteLibs = function (a, b)
            if (a.lanIp == lanIp and b != lanIp) then return -1
            if (a.lanIp != lanIp and b == lanIp) then return 1
        end function

        remoteLibsPrioritized = remote.remoteLibs.sort2(@sortRemoteLibs)
        for remoteLib in remoteLibsPrioritized
            breaches.scanAndExploit(remoteLib, lanIp)
        end for
	else
        localLibName = "init.so" // TODO cycle through them automatically if none is specified.
        // Should get their versions and prefer the ones we have addresses for.
		lib = Lib.metaxploit.load("/lib/"+localLibName)
        breaches.scanAndExploitLocal(lib, lanIp)
	end if

    breaches.print()
	breaches.handleInput(remote)
end function

module.exports = Hack
