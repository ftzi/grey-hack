#import Fs from "fs"
#import Std from "std"


Csv = {}

/*
  So it won't conflict with lists
 */
Csv.separator=";"

/*
  Reads a CSV file and parses it into a list of objects.

  @param {string} path
  @return {list<map>}
 */
Csv.read = function (path)
    content = Fs.read(path, false)
    if (content == null) then return null

    lines = content.split(Std.LF)
    columnsHeader = lines[0].split(Csv.separator)
    data = []

    for line in lines[1:]
        obj = {}
        columns = line.split(Csv.separator)
        for i in range(0, columnsHeader.len - 1)
            obj[columnsHeader[i]] = columns[i]
        end for
        data.push(obj)
    end for

    return data
end function

/*
  Writes one or more objects to a CSV file in sorted order based on the first column.

  @param {string} path
  @param {list<string>} headers
  @param {map|list<map>} objOrObjs
 */
Csv.writeOrdered = function (path, headers, objOrObjs, level = 1)
    if (not headers isa list or headers.len == 0) then throw("Headers must be a non-empty list.")
    content = Fs.read(path, false)
    if (content == null) then
        content = headers.join(Csv.separator)
    end if
    lines = content.split(Std.LF)
    if (lines[0] != headers.join(Csv.separator)) then
        throw("Headers don't match the file headers.")
    end if

    objs = objOrObjs
    if (not objs isa list) then objs = [objOrObjs]

    for obj in objs
        firstColumn = obj[headers[0]]

        insertionIndex = 1
        for line in lines[1:]
            columns = line.split(Csv.separator)
            if (firstColumn <= columns[0]) then
                break
            else
                insertionIndex = insertionIndex + 1
            end if
        end for

        newLine = []
        for header in headers
            newLine.push(obj[header])
        end for

        lines.insert(insertionIndex, newLine.join(Csv.separator))
    end for

    Fs.write(path, lines.join(Std.LF))
end function

module.exports = Csv
