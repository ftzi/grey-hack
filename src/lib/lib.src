#import Std from "std"

/*
  Map containing various libs that are lazy loaded and utility functions.

  @type Lib
 */
Lib = {}

Lib._libs = {}

/*
  Retrieves a library by name, loading it if not already cached.

  @param {string} name
  @return {object}
 */
Lib._getLib = function (name)
    if (not Lib._libs.hasIndex(name)) then Lib._libs[name] = Lib.load(name)
    return Lib._libs[name]
end function

/*
  Returns the metaxploit library instance.

  @return {metaxploit}
 */
Lib.metaxploit = function()
    return Lib._getLib("metaxploit")
end function

/*
  Returns the crypto library instance.

  @return {crypto}
 */
Lib.crypto = function()
    return Lib._getLib("crypto")
end function

/*
  Returns the aptClient library instance.

  @return {aptClient}
 */
Lib.aptClient = function()
    return Lib._getLib("aptclient")
end function

/*
  Returns the path to a library, searching in /lib and current directory.

  @param {string} name
  @param {boolean} installIfMissing
  @return {string}
 */
Lib.libPath = function (name, installIfMissing)
    libPath = "/lib/" + name
    if (get_shell.host_computer.File(libPath)) then return libPath
    localLibPath = current_path + "/" + name
    if (get_shell.host_computer.File(localLibPath)) then return localLibPath
    if (not installIfMissing) then
        throw("Can't find the <b>" + name + "</b> lib in the /lib path or the current folder.")
    end if

    error = Lib.aptClient.install(name)
    if (error) then throw ("Error installing the missing library "+name+": "+error)
    return libPath
end function

/*
  Returns the version of a local library

  @param {string} name
  @return {string}
 */
Lib.versionOf = function (name)
    return Lib.metaxploit.load(Lib.libPath(name.ensureSuffix(".so"), false)).version
end function

/*
  Loads a lib either by reading it from the "/lib" or from the current path.
  No need to provide the lib extension (".so").

  @param {string} name
  @return {object}
 */
Lib.load = function (name)
    if (name.indexOf(".so") == null) then name = name + ".so"
    lib = include_lib(Lib.libPath(name, true))
    if not lib then exit("Error loading the lib " + name)
    return lib
end function

/*
  Loads a library from a remote network session.

  @param {string} ip
  @param {number} port
  @return {metaLib}
 */
Lib.fromIpAndPort = function (ip, port)
    net = Lib.metaxploit.net_use(ip, port)
    if not net then exit("Error: can't connect to net session")
    if (net.is_root_active_user) then exit("Root user is active!")
    return net.dump_lib
end function

module.exports = Lib
