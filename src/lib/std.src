// Common functions and utils.

import_code("Std/string.src")
import_code("Std/number.src")
import_code("Std/collections.src")

Std = {}

/*
  Exits and prints the message in a pretty way.

  @param {string} message
  @returns never
 */
Std.throw = function (message)
    exit(toString(message).error)
end function

Std.programName = program_path.split("/")[-1]

// Functions references can be passed so they are only run deppending on the `condition`
Std.ifThenElse = function (condition, ifTrue, ifFalse)
    if (condition) then return ifTrue
    return ifFalse
end function

Std.Filters = {}
Std.Filters.byTruthyProp = function (key)
    fn = function (item)
        return (item.get(key)) != null and (item.get(key)) != false and (item.get(key)) != 0 and (item.get(key)) != ""
    end function

    return @fn
end function

/*
    ====================================================
    -=-=-=-=-=-=-=-=-=-=- NUMBER -=-=-=-=-=-=-=-=-=-=-=-
    ====================================================
*/


number.to_str = function (number)
    return ""+number
end function

number.bold = function (number)
    return "<b>"+self+"</b>"
end function


/*
    ====================================================
    -=-=-=-=-=-=-=-=-=-=- STRING -=-=-=-=-=-=-=-=-=-=-=-
    ====================================================
*/

// The game most usually doesn't handle "\n" well. It uses char(10) instead.
LF = char(10)

// Safely accesses a string by the index.
// Returns null if the index is invalid.
// @param {number} index
// @param {string|null} default
// @return {string|null}
string.get = function (index, default = null)
	if (self.hasIndex(index)) then return self[index] else return default
end function

string.fixNewLine = function ()
    self = self.replace("\n", LF)
    self = self.replace("\\n", LF)
    return self
end function

// Line Feed. Adds the newline char to the end of the string.
string.LF = function ()
    return self+LF // "\n" makes some native commands throw, like .build. Let's use char(10) as it's what's expected.
end function

string.bold = function ()
    return "<b>"+self+"</b>"
end function

string.italic = function ()
    return "<i>"+self+"</i>"
end function

string.color = function (color)
    return "<color="+color+">"+self+"</color=>"
end function

// Colors the string with the error color.
string.error = function ()
    return self.color("red")
end function

string.underline = function ()
    return "<u>"+self+"</u>"
end function

string.center=function()
    return "<align=center>"+self+"</align>"
end function

// Returns true if the string has the given substring.
// @return {number}
string.has = function (item)
	return self.indexOf(item) != null
end function

string.ensurePrefix = function (prefix)
    if (self[0:prefix.len] != prefix) then return prefix + self
    return self
end function
string.ensureSuffix = function (suffix)
    if (self[-suffix.len:] != suffix) then return self + suffix
    return self
end function
string.removePrefix = function (prefix)
    if (self[0:prefix.len] == prefix) then return self[prefix.len:]
    return self
end function
string.removeSuffix = function (suffix)
    if (self[-suffix.len:] == suffix) then return self[:-suffix.len]
    return self
end function

string.padLeft = function (length, char = " ")
    return (char * (length - self.len)) + self
end function

string.padRight = function (length, char = " ")
    return self + (char * (length - self.len))
end function

toString = function (value)
    if (value == null) then return "null"
    if (value isa string) then return value
    if (value isa number) then return ""+value
    if (value isa list) then return "["+value.join(", ")+"]"
    if (value isa map) then return "Object"
end function

string.f = function (a,b,c,d,e,f,g)
    list = [a,b,c,d,e,f,g]
    index = 0
    newStr = ""
    for char in self
        if (char == "$") then
            newStr = newStr + toString(list[index])
            index = index + 1
        else
            newStr = newStr + char
        end if
    end for
    return newStr
end function

// Removes whitespaces from both ends of the string.
string.trim = function ()
    self = self.fixNewLine()
    removables = [" ", LF]
    xHead = true
    xTail = true

    while (xHead or xTail)
        // TODO handle invalid indexes if length becomes 0
        if (removables.indexOf(self.get(0)) != null) then
            self = self[1:]
        else
            xHead = false
        end if
        if (removables.indexOf(self.get(-1)) != null) then
            self = self[:-1]
        else
            xTail = false
        end if
    end while

	return self
end function

// Returns the substring between two other substrings.
// If "" or null is given to open, it will consider the beginning of the string; index 0.
// If null is given to close, it will consider either a NewLine or the end of the string.
string.valueBetween = function (open = null, close = null)
    if (open == null) then open = ""
    self = self.fixNewLine()

    if (close == null) then
		self = self.ensureSuffix(LF)
		close = LF
	end if

	head = self.indexOf(open)
	if (head == null) then return

    tail = self.indexOf(close, head + open.len)
    if (tail != null) then return self[head + open.len:tail]
end function

// Returns all the occurrences as a list of the substrings
// between two other substrings
string.valuesBetween = function (open, close)
	array = []
	head = null
	tail = null
	while true
		head = self.indexOf(open, tail)
        if (head == null) then break
		tail = self.indexOf(close, head + open.len)
        if (tail == null) then break
		array.push(self[head + open.len:tail])
	end while

	return array
end function

// Joins the self path and the given ones with `/`.
string.join = function (a, b, c, d, e)
    paths = [a, b, c, d, e]
    for path in paths
        if (path == null) then return self
        self = self.ensureSuffix("/") + path.removePrefix("/")
    end for
    return self
end function

string.parent = function ()
    return parent_path(self)
end function

string.filename = function ()
    return self.removeSuffix("/").split("/")[-1]
end function

// If the string is not an absolute path, it will add the current path to it.
string.absolutePath = function ()
    if (self[0] != "/") then return current_path + "/" + self
    return self
end function

/*
    ====================================================
    -=-=-=-=-=-=-=-=-=-=-=- MAP -=-=-=-=-=-=-=-=-=-=-=-
    ====================================================
*/

// Safely gets the value of an object by passing the keys to access it.
// Pass either a string or a list of keys to deeply access it.
// Returns null if the final property is not found.
map.get = function (keys)
	if not (keys isa list) then keys = [keys]
	data = self
	for key in keys
		if (data.hasIndex(key)) then data = @data[key] else return null
	end for
	return @data
end function

map.set = function (keys, value)
    if not (keys isa list) then keys = [keys]
    data = self
    for key in keys[:-1]
        if (not data.hasIndex(key)) then data[key] = {}
        data = @data[key]
    end for
    data[keys[-1]] = value
end function

// Removes the items of a list when the given function returns not-true for each item.
list.filter = function (fn)
	newList = []
	for item in self
		if (fn(item)) then newList.push(item)
	end for
	return newList
end function


/*
    ====================================================
    -=-=-=-=-=-=-=-=-=-=-=- LIST -=-=-=-=-=-=-=-=-=-=-=-
    ====================================================
*/


list.filterBy = function()
    _self = self
    filters = {}
    filters.truthyProp = function (key)
        return _self.filter(@Filters.byTruthyProp(key))
    end function

    return filters
end function


list.sort2 = function (compareFn)
    newList = self[:]
    for i in range (0, newList.len - 1)
        for j in range(0, newList.len - 2)
            if (compareFn(newList[j], newList[j + 1]) > 0) then
                temp = newList[j]
                newList[j] = newList[j + 1]
                newList[j + 1] = temp
            end if
        end for
    end for
    return newList
end function

// Safely accesses a list item by the index.
// Returns null if the index is invalid.
list.get = function (index, default = null)
	if (self.hasIndex(index)) then return @self[index] else return default
end function

// Returns true if the list includes the given item.
// @return {number}
list.has = function (item)
	return self.indexOf(item) != null
end function

// Only adds if the list doesn't have this item yet.
list.addUnique = function (item)
    if (not self.has(item)) then self.push(item)
end function

// Deletes the first occurrence of an item in the list. Mutates that list.
list.delete = function (item)
    index = self.indexOf(item)
    if (index != null) then self.remove(index)
end function

// Transforms each item of a list by using the given function.
list.map = function (fn)
	newList = []
	for item in self
		newList.push(fn(item))
	end for
	return newList
end function

list.toString = function (spaced = false)
    if (spaced) then return "["+self.join(", ")+"]"
    return "["+self.join(",")+"]"
end function

module.exports = Std
