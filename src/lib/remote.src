#import Std from "std"
#import Lib from "lib"
#import Addresses from "addresses"

/*
  @type {Who}
 */
Who = {}

/*
  @param {string} ip
  @return {Who}
 */
Who.New = function (ip)
    who = new Who
    whoisOutput = whois(ip)
    whoisLines = whoisOutput.split(Std.LF)
    who.ip = ip
    who.domain = whoisLines[0].split(":")[1].trim
    who.admin = {}
    who.admin.name = whoisLines[1].split(":")[1].trim
    who.admin.email = whoisLines[2].split(":")[1].trim
    who.admin.phone = whoisLines[3].split(":")[1].trim
    return who
end function

/*
  @return {null}
 */
Who.print = function ()
    print("IP: $ Domain: $".f(self.ip.bold, self.domain.bold))
    print("Admin: $ Email: $".f(self.admin.name.bold, self.admin.email.bold).LF)
end function

/*
  @type {XLib}
  @property {Remote} remote
  @property {Lib} lib
  @property {string} service
  @property {number} portNumber
  @property {string} lanIp
  @property {number} canUse
  @property {number} hasAddresses
  @property {string} name
  @property {string} version
 */
XLib = {}

/*
  @param {Remote} remote
  @param {port} port

  @return {XLib}
 */
XLib.New = function (remote, port = null)
    xlib = new XLib
    xlib.remote = remote
    if (port) then
        xlib.service = remote.router.port_info(port).split(" ")[0] // [1] is lib version
        xlib.portNumber = port.port_number
        xlib.lanIp = port.get_lan_ip
        xlib.canUse = remote.isLanIp or not port.is_closed
    else
        xlib.service = "router"
        xlib.portNumber = 0
        xlib.lanIp = remote.router.local_ip
        xlib.canUse = true
    end if
    xlib.lib = Lib.loadRemote(remote.ip, xlib.portNumber)
    xlib.hasAddresses = Addresses.hasLocalAddressesFor(xlib.lib)
    xlib.name = xlib.lib.lib_name
    xlib.version = xlib.lib.version
    return xlib
end function

/*
  Remote is not a good name. How should it be called? XRouter?

  @type {Remote}
  @property {string} ip
  @property {bool} isLanIp
  @property {Router} router
  @property {Who} who
  @property {list<port>} ports
  @property {list<XLib>} xlibs
  @property {XLib} lib
 */
Remote = {}

/*
  @param {XLib} a
  @param {XLib} b
  @return {number}
 */
Remote._sortXlibs = function (a, b)
    if (a.lanIp < b.lanIp) then return -1
    if (a.lanIp == b.lanIp) then
        if (a.portNumber < b.portNumber) then return -1
        return 1
    end if
    return 1
end function

/*
  @param {string} ip
  @return {Remote}
 */
Remote.New = function (ip)
	if (not is_valid_ip(ip)) then throw("Invalid ip: " + ip)
	if (not get_shell.ping(ip)) then throw("IP address not found")

    remote = new Remote
    remote.ip = ip
    remote.isLanIp = is_lan_ip(ip)
    remote.router = get_router(Std.ifThenElse(remote.isLanIp, "", ip))
    remote.who = Who.New(ip)
    remote.ports = Remote._getPorts(remote)
    remote.xlibs = [XLib.New(remote, null)]
    for port in remote.ports
        xlib = XLib.New(remote, port)
        remote.xlibs.push(xlib)
    end for
    remote.lib = remote.xlibs[0].lib // not needed? currently used as first option in y
    remote.xlibs = remote.xlibs.sort2(@Remote._sortXlibs)

	return remote
end function

/*
  @param {Remote} remote
  @return {list<port>}
 */
Remote._getPorts = function (remote)
    ports = null
    if is_lan_ip(remote.ip) then
        ports = remote.router.device_ports(remote.ip)
    else
        ports = remote.router.used_ports
    end if

    if (ports == null) then ports = "IP address not found"
	if (ports isa string) then throw("Error: " + ports)

    return ports
end function

/*
  @return {null}
 */
Remote.printFirewallRules = function ()
    firewall_rules = self.router.firewall_rules
    if (firewall_rules isa string) then throw(firewall_rules)

    if firewall_rules.len == 0 then
        print("No firewall rules found.".color("grey").LF)
    else
        firewallMessage = "ACTION PORT SOURCE_IP DESTINATION_IP"
        for rules in firewall_rules
            firewallMessage = firewallMessage.LF + rules
        end for
        print(format_columns(infirewallMessagefo).LF)
    end if
end function

/*
  @return {null}
 */
Remote.print = function ()
    self.who.print()

    info = "PORT STATE SERVICE VERSION LAN"
    for xlib in self.xlibs
        version = xlib.version + Std.ifThenElse(xlib.hasAddresses, "+", "")
        info = info.LF + [xlib.portNumber, Std.ifThenElse(xlib.canUse, "open", "close"), xlib.service, version, xlib.lanIp].join(" ")
    end for

    formatted = format_columns(info).split(Std.LF)
    print(formatted[0].color("green"))
    print(formatted[1:].join(Std.LF).LF)
    self.printFirewallRules()
end function
