#import Std from "std"
#import Lib from "lib"
#import Addresses from "addresses"

/*
  @type WhoIs
 */
WhoIs = {}

/*
  Creates a new WhoIs object by performing a whois lookup on the given IP.

  @param {string} ip
  @return {WhoIs}
 */
WhoIs.New = function (ip)
    whoIs = new WhoIs
    whoisOutput = whois(ip)
    whoisLines = whoisOutput.split(Std.LF)
    whoIs.ip = ip
    whoIs.domain = whoisLines[0].split(":")[1].trim
    whoIs.admin = {}
    whoIs.admin.name = whoisLines[1].split(":")[1].trim
    whoIs.admin.email = whoisLines[2].split(":")[1].trim
    whoIs.admin.phone = whoisLines[3].split(":")[1].trim
    return whoIs
end function

/*
  Prints the IP, domain, admin name, and email information.

  @return {null}
 */
WhoIs.print = function ()
    print("IP: $ Domain: $".f(self.ip.bold, self.domain.bold))
    print("Admin: $ Email: $".f(self.admin.name.bold, self.admin.email.bold).LF)
end function

/*
  @type RemoteLib
  @property {Remote} remote
  @property {Lib} lib
  @property {string} service
  @property {number} portNumber
  @property {string} lanIp
  @property {number} canUse
  @property {number} hasAddresses
  @property {string} name
  @property {string} version
 */
RemoteLib = {}

/*
  Creates a new RemoteLib object representing a library on a remote port.

  @param {Remote} remote
  @param {port|null} port
  @return {RemoteLib}
 */
RemoteLib.New = function (remote, port = null)
    remoteLib = new RemoteLib
    remoteLib.remote = remote
    if (port) then
        remoteLib.service = remote.router.port_info(port).split(" ")[0] // [1] is lib version
        remoteLib.portNumber = port.port_number
        remoteLib.lanIp = port.get_lan_ip
        remoteLib.canUse = remote.isLanIp or not port.is_closed
    else
        remoteLib.service = "router"
        remoteLib.portNumber = 0
        remoteLib.lanIp = remote.router.local_ip
        remoteLib.canUse = true
    end if
    remoteLib.metaLib = Lib.fromIpAndPort(remote.ip, remoteLib.portNumber)
    remoteLib.hasAddresses = Addresses.hasLocalAddressesFor(remoteLib.metaLib)
    remoteLib.name = remoteLib.metaLib.lib_name
    remoteLib.version = remoteLib.metaLib.version
    return remoteLib
end function

/*
  Remote is not a good name. How should it be called? XRouter?

  @type Remote
  @property {string} ip
  @property {bool} isLanIp
  @property {Router} router
  @property {WhoIs} whoIs
  @property {list<port>} ports
  @property {list<RemoteLib>} remoteLibs
 */
Remote = {}

/*
  Comparison function for sorting RemoteLib objects by LAN IP and port number.

  @param {RemoteLib} a
  @param {RemoteLib} b
  @return {number}
 */
Remote._sortRemoteLibs = function (a, b)
    if (a.lanIp < b.lanIp) then return -1
    if (a.lanIp == b.lanIp) then
        if (a.portNumber < b.portNumber) then return -1
        return 1
    end if
    return 1
end function

/*
  Creates a new Remote object for the given IP, loading router and port info.

  @param {string} ip
  @return {Remote}
 */
Remote.New = function (ip)
	if (not is_valid_ip(ip)) then Std.throw("Invalid ip: " + ip)
	if (not get_shell.ping(ip)) then Std.throw("IP address not found")

    remote = new Remote
    remote.ip = ip
    remote.isLanIp = is_lan_ip(ip)
    remote.router = get_router(Std.ifThenElse(remote.isLanIp, "", ip))
    remote.whoIs = WhoIs.New(ip)
    remote.ports = Remote._getPorts(remote)
    remote.remoteLibs = [RemoteLib.New(remote, null)]
    for port in remote.ports
        remoteLib = RemoteLib.New(remote, port)
        remote.remoteLibs.push(remoteLib)
    end for
    remote.remoteLibs = remote.remoteLibs.sort2(@Remote._sortRemoteLibs)

	return remote
end function

/*
  Retrieves the list of ports for a remote target based on its IP type.

  @param {Remote} remote
  @return {list<port>}
 */
Remote._getPorts = function (remote)
    ports = null
    if is_lan_ip(remote.ip) then
        ports = remote.router.device_ports(remote.ip)
    else
        ports = remote.router.used_ports
    end if

    if (ports == null) then ports = "IP address not found"
	if (ports isa string) then Std.throw("Error: " + ports)

    return ports
end function

/*
  Prints the firewall rules for the remote router.

  @return {null}
 */
Remote.printFirewallRules = function ()
    firewall_rules = self.router.firewall_rules
    if (firewall_rules isa string) then Std.throw(firewall_rules)

    if firewall_rules.len == 0 then
        print("No firewall rules found.".color("grey").LF)
    else
        firewallMessage = "ACTION PORT SOURCE_IP DESTINATION_IP"
        for rules in firewall_rules
            firewallMessage = firewallMessage.LF + rules
        end for
        print(format_columns(infirewallMessagefo).LF)
    end if
end function

/*
  Prints full remote information including whois data, ports, and firewall rules.

  @return {null}
 */
Remote.print = function ()
    self.whoIs.print()

    info = "PORT STATE SERVICE LIB VERSION LAN"
    for remoteLib in self.remoteLibs
        version = remoteLib.version + Std.ifThenElse(remoteLib.hasAddresses, "+", "")
        info = info.LF + [remoteLib.portNumber, Std.ifThenElse(remoteLib.canUse, "open", "close"), remoteLib.service, remoteLib.name, version, remoteLib.lanIp].join(" ")
    end for

    formatted = format_columns(info).split(Std.LF)
    print(formatted[0].color("green"))
    print(formatted[1:].join(Std.LF).LF)
    self.printFirewallRules()
end function

module.exports = Remote
