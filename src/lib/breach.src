#import Lib from "lib"
#import XFile from "xfile"

/*
  @type Breach

  @property {string} type - Type of breach data: "shell", "computer", or "file"
  @property {shell|null} shell - Shell access if available
  @property {computer|null} computer - Computer access if available
  @property {XFile|null} xfile - File system access wrapper
  @property {function|null} action - Action handler for this breach type
 */
Breach = {}

/*
  Creates a new Breach instance.

  @param {any} data - Shell, computer, or file object

  @return {Breach}
 */
Breach.New = function(data)
	breach = new Breach
	breach.type = typeof(data)
	breach.shell = null
	breach.computer = null
	breach.xfile = null
	breach.action = null

  print("Typeof breach: $".f(typeof(data)))

	if (breach.type == "shell") then
		breach.shell = data
		if (breach.shell.host_computer) then
			breach.computer = breach.shell.host_computer
			rootFile = breach.computer.File("/")
			if (rootFile) then breach.xfile = XFile.New(rootFile)
		end if
		breach.action = @Breach.actionShell
	else if (breach.type == "computer") then
		breach.computer = data
		rootFile = breach.computer.File("/")
		if (rootFile) then breach.xfile = XFile.New(rootFile)
		breach.action = @Breach.actionComputer
	else if (breach.type == "file") then
		breach.xfile = XFile.New(data)
		breach.action = @Breach.actionFile
	end if
	return breach
end function

/*
  Interactive action for computer-type breaches.
  Allows browsing and reading files on the compromised computer.

  @return {null}
 */
Breach.actionComputer = function()
	while (true)
		input = user_input("Enter the path of the file to be shown or nothing to go back:".LF)
		if (input == "") then return

		if (input.indexOf("..") != null or input.indexOf("~") != null) then
			print("Invalid path. Path traversal attempts are not allowed.")
			continue
		end if

		file = self.computer.File(input)
		if (not file) then
			print("File not found: " + input)
			continue
		end if

		if (not file.has_permission("r")) then
			print("You don't have the permission to read it")
		else if (file.is_folder) then
			print(file.get_files + file.get_folders)
		else if (file.is_binary) then
			print("File is binary, no action is possible yet.")
		else
			print(file.get_content)
		end if
	end while
end function

/*
  Seeds essential tools to a shell.
  Copies metaxploit, crypto libraries and program to the target shell.

  @param {shell} shell - Target shell to seed files to
  @return {null}
 */
Breach.seedShellFiles = function (shell)
	get_shell.scp(Lib.libPath("metaxploit.so"), "/home/guest", shell)
	get_shell.scp(Lib.libPath("crypto.so"), "/home/guest", shell)

  result = get_shell.scp(program_path, "/home/guest", shell)
  if typeof(result) == "string" then
    print("There was an error while sending file: " + result)
  end if
end function

/*
  Interactive action for shell-type breaches.
  Seeds tools and starts an interactive terminal.

  @return {null}
 */
Breach.actionShell = function ()
	Breach.seedShellFiles(self.shell)
	self.shell.start_terminal
end function

/*
  Interactive action for file-type breaches.
  Displays file metadata and content if readable.

  @return {null}
 */
Breach.actionFile = function ()
	if (not self.xfile or not self.xfile._file) then
		print("Error: No file available")
		return
	end if

	file = self.xfile._file
	print("File: " + file.path)
	print("Permissions: " + file.permissions)
	print("Owner: " + self.xfile.user)
	print("Is folder: " + file.is_folder)
	print("Is binary: " + file.is_binary)

	if (not file.is_folder and not file.is_binary and file.has_permission("r")) then
		print("".LF + "Content:")
		print(file.get_content)
	end if
end function

module.exports = Breach
