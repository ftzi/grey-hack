#import Lib from "lib"
#import Std from "std"
#import XFile from "xfile"
#import Addresses from "addresses"

/*
  @type Breach
 */
Breach = {}

/*
  @param {any} data
  @param {number} address
  @param {string} unsecZone
  @param {list} extra
  @param {string} lanIp

  @return {Breach}
 */
Breach.New = function(data, address, unsecZone, extra, lanIp = null)
	breach = new Breach
	breach.type = typeof(data)
	breach.address = address
	breach.unsecZone = unsecZone
	breach.extra = extra
	breach.shell = null
	breach.computer = null
	breach.xfile = null
	breach.action = null
    breach.lanIp = lanIp

	if (breach.type == "shell") then
		breach.shell = data
		breach.computer = breach.shell.host_computer
		breach.xfile = XFile.New(breach.computer.File("/"))
		breach.action = @breach.actionShell
	else if (breach.type == "computer") then
		breach.computer = data
		breach.xfile = XFile.New(breach.computer.File("/"))
		breach.action = @breach.actionComputer
	else if (breach.type == "file") then
		breach.xfile = XFile.New(data)
	end if
	return breach
end function

/*
  @return {null}
 */
Breach.actionComputer = function()
	while (true)
		input = user_input("Enter the path of the file to be shown or nothing to go back:".LF)
		if (input == "") then return
		file = self.computer.File(input)

		if (not file.has_permission("r")) then
			print("You don't have the permission to read it")
		else if (file.is_folder) then
			print(file.get_files + file.get_folders)
		else if (file.is_binary) then
			print("File is binary, no action is possible yet.")
		else
			print(file.get_content)
		end if
	end while
end function

/*
  @return {null}
 */
Breach.actionShell = function ()
	get_shell.scp(Lib.libPath("metaxploit.so"), "/home/guest", self.shell)
	get_shell.scp(Lib.libPath("crypto.so"), "/home/guest", self.shell)
	get_shell.scp(program_path, "/home/guest", self.shell)
	self.shell.start_terminal
end function

/*
  @type Breachs
 */
Breachs = {}

/*
    Create a new Breachs instance.

    @param {string|null} publicIp
    @return {Breachs}
 */
Breachs.New = function (publicIp = null)
    breaches = new Breachs
    breaches.publicIp = publicIp
    breaches.all = []
    breaches.withAction = []
    breaches.withShell = []
    breaches.withXFile = []
    return breaches
end function

/*
  Retrieves the contents of /etc/passwd from the first available xfile.

  @return {string|null}
 */
Breachs.passwd = function()
	for breach in self.withXFile
	    return breach.xfile.contentAt("/etc/passwd")
	end for
end function

/*
  Extracts unique usernames from the passwd file.

  @return {list}
 */
Breachs.users = function ()
    users = []
    passwd = self.passwd
    if (passwd) then
        for line in passwd.trim.split(Std.LF)
            users.addUnique(line.valueBetween(null, ":"))
        end for
    end if
    return users
end function

/*
  Scans and exploits a remote library.

  @param {RemoteLib} remoteLib
  @param {string} lanIp
 */
Breachs.scanAndExploit = function (remoteLib, lanIp = "")
    lib = remoteLib.lib
	for address in Addresses.addressesFor(lib)
		scanResult = Lib.metaxploit.scan_address(lib, address)
		scanResult = scanResult.replace("decompiling source...\nsearching unsecure values...\n", "")
		scanResult = scanResult.replace("\n\n\n", "")

		entries = scanResult.split("\n\n")
		if entries[entries.len -1] == "" then entries.pop()

		for entry in entries
			unsecZone = entry.valueBetween("<b>", "</b>")
			data = lib.overflow(address, unsecZone, lanIp)
			print("====================")

			if (not ["computer", "shell", "file"].has(typeof(data))) then continue

			extra = (entry.LF).valuesBetween("* ", Std.LF)
			breach = Breach.New(data, address, unsecZone, extra, remoteLib.lanIp)
			self.all.push(breach)
		end for
	end for
	self.withAction = self.all.filter(Std.Filters.byTruthyProp("action"))
	self.withShell = self.all.filter(Std.Filters.byTruthyProp("shell"))
	self.withXFile = self.all.filter(Std.Filters.byTruthyProp("xfile"))
end function

/*
  Scans and exploits a local library.

  @param {lib} lib
  @param {string} lanIp
 */
Breachs.scanAndExploitLocal = function (lib, lanIp = "")
	for address in Addresses.addressesFor(lib)
		scanResult = Lib.metaxploit.scan_address(lib, address)
		scanResult = scanResult.replace("decompiling source...\nsearching unsecure values...\n", "")
		scanResult = scanResult.replace("\n\n\n", "")

		entries = scanResult.split("\n\n")
		if entries[entries.len -1] == "" then entries.pop()

		for entry in entries
			unsecZone = entry.valueBetween("<b>", "</b>")
			data = lib.overflow(address, unsecZone, lanIp)
			print("====================")

			if (not ["computer", "shell", "file"].has(typeof(data))) then continue

			extra = (entry.LF).valuesBetween("* ", Std.LF)
			breach = Breach.New(data, address, unsecZone, extra, lanIp)
			self.all.push(breach)
		end for
	end for
	self.withAction = self.all.filter(Std.Filters.byTruthyProp("action"))
	self.withShell = self.all.filter(Std.Filters.byTruthyProp("shell"))
	self.withXFile = self.all.filter(Std.Filters.byTruthyProp("xfile"))
end function

/*
  @return {null}
 */
Breachs.print = function ()
	message = "Ix LAN_IP TYPE DATA"
	i = -1
	for breach in self.withAction
		i = i + 1
		message = message.LF + "$ $ $".f(i, breach.lanIp ,breach.type)
		if (breach.type == "computer") then message = message + " "+ breach.xfile.user
		if (breach.type == "shell") then message = message + " "+ breach.xfile.user
		if (breach.type == "file") then
			message = message + " " + file.path
			if (file.is_folder) then message = message + "/"
			message = message + " " + file.permissions + " " + breach.xfile.user
		end if
	end for

	print(format_columns(message).LF)

    if (self.passwd) then
        message = "Found passwd. Usage: p [index = 0] [-d (decipherOnly)] [-p <password>].".LF
        i = 0
        for line in self.passwd.trim.split(Std.LF)
            message = "$p $) $".f(message, i, line).LF
            i = i + 1
        end for
        print(message)
	end if
    print("Users: " +self.users.join(", "))
end function

/*
  @param {string} user
  @param {string} password

  @return {null}
 */
Breachs._connectSsh = function (user, password)
    shell = null
    if (self.publicIp) then
        shell = get_shell.connect_service(self.publicIp, 22, user, password)
        if (not shell or shell isa string) then
            canConnectWithShell = self.withShell.len != 0
            message = "Using hacked shell to login as this user."
            if (not canConnectWithShell) then message = "There is no available shell to make the indirect login."
            print("Couldn't connect with ssh: " + shell + message)
            if (canConnectWithShell) then self.withShell[0].shell.launch("sudo", "-s " + password)
            return
        end if
    else
        shell = get_shell(user, password)
    end if
    if (shell isa map) then shell.start_terminal else print("Could not connect via ssh to "+user+"@"+password+". Error: "+shell)
end function

Breachs.inputHandler = {}

/*
  Handles password-related input commands to decipher and connect via SSH.

  @param {list} inputParams
  @return {null}
 */
Breachs.inputHandler.password = function (inputParams)
    if (not self.passwd) then return
    decipherOnly = inputParams.has("-d")
    inputParams.delete("-d")

    indexPasswordOption = inputParams.indexOf("-p")
    password = null
    if (indexPasswordOption != null) then
        password = inputParams[indexPasswordOption + 1]
        inputParams.remove(indexPasswordOption)
        inputParams.remove(indexPasswordOption) // It's not +1 as we just removed it!
    end if

    indexEntry = inputParams.get(1, "0").to_int

    passwds = self.passwd.split(Std.LF)
    chosenPasswd = passwds[indexEntry]
    user = chosenPasswd.valueBetween(null, ":")

    if (not password) then
        print("Deciphering the password of <b>"+user+"</b>...")
        wait(0.01)
        password = Lib.crypto.decipher(chosenPasswd.valueBetween(":"))
        print("Password of <b>" + user + "</b> is <b>" + password + "</b>".LF)
        if (decipherOnly) then return
    end if

    self._connectSsh(user, password)
end function

/*
  @param {Remote} remote

  @return {null}
 */
Breachs.handleInput = function (remote)
	while true
		inputParams = user_input("Enter the desired method:".LF).split(" ")
		if (inputParams[0] == "p") then
            self.inputHandler.password(remote, inputParams)
		else
            index = inputParams[0].to_int
            if (not self.withAction.hasIndex(index)) then
                print("Invalid option.")
                continue
            end if

			self.withAction[index].action()
		end if
		print()
	end while
end function

module.exports = Breachs
