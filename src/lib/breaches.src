#import Lib from "lib"
#import Std from "std"
#import Breach from "breach"
#import Addresses from "addresses"
#import XCrypto from "xcrypto"

/*
  @type Breachs - Collection of breaches with scanning and query capabilities

  @property {string|null} publicIp - Public IP address being targeted
  @property {list<Breach>} all - All discovered breaches
  @property {list<Breach>} withAction - Breaches that have action handlers
  @property {list<Breach>} withShell - Breaches that provide shell access
  @property {list<Breach>} withXFile - Breaches that provide file system access
  @property {XCrypto} xcrypto - Password caching and decryption utility
 */
Breachs = {}

/*
  Creates a new Breachs instance.

  @param {string|null} publicIp - Public IP address being targeted
  @return {Breachs}
 */
Breachs.New = function (publicIp = null)
  breaches = new Breachs
  breaches.publicIp = publicIp
  breaches.all = []
  breaches.withAction = []
  breaches.withShell = []
  breaches.withXFile = []
  breaches.xcrypto = XCrypto.New()
  return breaches
end function

/*
  Retrieves the contents of /etc/passwd from the first available xfile.
  Filters out permission errors and returns only valid content.

  @return {string|null}
 */
Breachs.passwd = function()
	for breach in self.withXFile
		content = breach.xfile.contentAt("/etc/passwd")
		if (content and not content.indexOf("Permission denied") and not content.indexOf("can't open")) then
			return content
		end if
	end for
	return null
end function

/*
  Extracts unique usernames from the passwd file.

  @return {list}
 */
Breachs.users = function ()
    users = []
    passwd = self.passwd
    if (passwd) then
        for line in passwd.trim.split(Std.LF)
            users.addUnique(line.valueBetween(null, ":"))
        end for
    end if
    return users
end function

/*
  Internal helper to process scan results and create breaches.
  Scans addresses, exploits vulnerabilities, and categorizes results.

  @param {lib} lib - Library to exploit
  @param {string} lanIp - LAN IP address
 */
Breachs._processScanResults = function (lib, lanIp)
	for address in Addresses.addressesFor(lib)
		scanResult = Lib.metaxploit.scan_address(lib, address)
    print(scanResult)
		if (not scanResult or typeof(scanResult) != "string") then continue

		scanResult = scanResult.replace("decompiling source...\nsearching unsecure values...\n", "")
		scanResult = scanResult.replace("\n\n\n", "")

		entries = scanResult.split("\n\n")
		if entries.len > 0 and entries[entries.len -1] == "" then entries.pop()

		for entry in entries
			unsecZone = entry.valueBetween("<b>", "</b>")
			if (not unsecZone) then continue

			data = lib.overflow(address, unsecZone, lanIp)
			print("====================")

			if (not ["computer", "shell", "file"].has(typeof(data))) then continue

			extra = (entry.LF).valuesBetween("* ", Std.LF)
			breach = Breach.New(data, address, unsecZone, extra, lanIp)
			self.all.push(breach)
		end for
	end for
	self.withAction = self.all.filter(Std.Filters.byTruthyProp("action"))
	self.withShell = self.all.filter(Std.Filters.byTruthyProp("shell"))
	self.withXFile = self.all.filter(Std.Filters.byTruthyProp("xfile"))
end function

/*
  Scans and exploits a remote library.

  @param {RemoteLib} remoteLib - Remote library object with lib and lanIp
  @param {string} lanIp - Optional LAN IP override
 */
Breachs.scanAndExploit = function (remoteLib, lanIp = "")
	if (not remoteLib or not remoteLib.lib) then
		print("Error: Invalid remote library")
		return
	end if
	self._processScanResults(remoteLib.lib, remoteLib.lanIp)
end function

/*
  Scans and exploits a local library.

  @param {lib} lib - Library to exploit
  @param {string} lanIp - LAN IP address
 */
Breachs.scanAndExploitLocal = function (lib, lanIp = "")
	if (not lib) then
		print("Error: Invalid library")
		return
	end if
	self._processScanResults(lib, lanIp)
end function

module.exports = Breachs
