#import Lib from "lib"
#import Std from "std"
#import Breach from "breach"
#import Addresses from "addresses"
#import XCrypto from "xcrypto"

/*
  @type Breachs - Collection of breaches with scanning and query capabilities

  @property {string|null} publicIp - Public IP address being targeted
  @property {list<Breach>} all - All discovered breaches
  @property {list<Breach>} withAction - Breaches that have action handlers
  @property {list<Breach>} withShell - Breaches that provide shell access
  @property {list<Breach>} withXFile - Breaches that provide file system access
 */
Breachs = {}

/*
  Creates a new Breachs instance.

  @param {string|null} publicIp - Public IP address being targeted
  @return {Breachs}
 */
Breachs.New = function (publicIp = null)
  breaches = new Breachs
  breaches.publicIp = publicIp
  breaches.all = []
  breaches.withAction = []
  breaches.withShell = []
  breaches.withXFile = []
  return breaches
end function

/*
  Retrieves the contents of /etc/passwd from the first available xfile.
  Returns null if no readable passwd file is found.

  @return {string|null}
 */
Breachs.passwd = function()
	for xfile in self.xfiles()
		content = xfile.contentAt("/etc/passwd")
		if (content) then return content
	end for
end function

/*
  Extracts unique usernames from the passwd file.
  Uses a map to ensure no duplicates, returns as a sorted list.

  @return {list}
 */
Breachs.users = function ()
    users = {}
    passwd = self.passwd
    if (passwd) then
        for line in passwd.trim.split(Std.LF)
            user = line.valueBetween(null, ":")
            if (user) then users[user] = true
        end for
    end if
    return users.indexes
end function

/*
  Returns all xfiles from all breaches with file system access.

  @return {list<XFile>}
 */
Breachs.xfiles = function()
    result = []
    for breach in self.withXFile
        result.push(breach.xfile)
    end for
    return result
end function

/*
  Internal helper to process scan results and create breaches.
  Scans addresses, exploits vulnerabilities, and categorizes results.

  @param {metaLib} metaLib - Library to exploit
  @param {string} optArgs - LAN IP address
 */
Breachs.scanAndProcessMetaLib = function (metaLib, optArgs)
	for address in Addresses.addressesFor(metaLib)
		scanResult = Lib.metaxploit.scan_address(metaLib, address)
    // print(scanResult)
		if (not scanResult or typeof(scanResult) != "string") then continue

		scanResult = scanResult.replace("decompiling source...\nsearching unsecure values...\n", "")
		scanResult = scanResult.replace("\n\n\n", "")

		entries = scanResult.split("\n\n")
		if entries.len > 0 and entries[entries.len -1] == "" then entries.pop()

		for entry in entries
			unsecZone = entry.valueBetween("<b>", "</b>")
			if (not unsecZone) then continue

      // print("Overflowing address <$>, unsecZone <$>, optArgs <$>".f(address, unsecZone, optArgs))
			data = metaLib.overflow(address, unsecZone, optArgs)
			print("====================")

			if (not ["computer", "shell", "file"].has(typeof(data))) then continue

			breach = Breach.New(data)
			self.all.push(breach)
		end for
	end for

	self.withAction = self.all.filter(Std.Filters.byTruthyProp("action"))
	self.withShell = self.all.filter(Std.Filters.byTruthyProp("shell"))
	self.withXFile = self.all.filter(Std.Filters.byTruthyProp("xfile"))
end function

module.exports = Breachs
