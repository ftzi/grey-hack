#import Lib from "lib"
#import Std from "std"
#import Breach from "breach"
#import Addresses from "addresses"
#import XCrypto from "xcrypto"

/*
  @type Breachs - Collection of breaches with scanning and query capabilities

  @property {string|null} publicIp - Public IP address being targeted
  @property {list<Breach>} all - All discovered breaches
  @property {list<Breach>} withAction - Breaches that have action handlers
  @property {list<Breach>} withShell - Breaches that provide shell access
  @property {list<Breach>} withXFile - Breaches that provide file system access
 */
Breachs = {}

/*
  Creates a new Breachs instance.

  @param {string|null} publicIp - Public IP address being targeted
  @return {Breachs}
 */
Breachs.New = function (publicIp = null)
  breaches = new Breachs
  breaches.publicIp = publicIp
  breaches.all = []
  breaches.withAction = []
  breaches.withShell = []
  breaches.withXFile = []
  return breaches
end function

/*
  Retrieves the contents of /etc/passwd from the first available xfile.
  Filters out permission errors and returns only valid content.

  @return {string|null}
 */
Breachs.passwd = function()
	for breach in self.withXFile
		content = breach.xfile.contentAt("/etc/passwd")
		if (content and not content.indexOf("Permission denied") and not content.indexOf("can't open")) then
			return content
		end if
	end for
	return null
end function

/*
  Extracts unique usernames from the passwd file.

  @return {list}
 */
Breachs.users = function ()
    users = []
    passwd = self.passwd
    if (passwd) then
        for line in passwd.trim.split(Std.LF)
            users.addUnique(line.valueBetween(null, ":"))
        end for
    end if
    return users
end function

/*
  Internal helper to process scan results and create breaches.
  Scans addresses, exploits vulnerabilities, and categorizes results.

  @param {metaLib} metaLib - Library to exploit
  @param {string} optArgs - LAN IP address
 */
Breachs._processScanResults = function (metaLib, optArgs)
	for address in Addresses.addressesFor(metaLib)
		scanResult = Lib.metaxploit.scan_address(metaLib, address)
    print(scanResult)
		if (not scanResult or typeof(scanResult) != "string") then continue

		scanResult = scanResult.replace("decompiling source...\nsearching unsecure values...\n", "")
		scanResult = scanResult.replace("\n\n\n", "")

		entries = scanResult.split("\n\n")
		if entries.len > 0 and entries[entries.len -1] == "" then entries.pop()

		for entry in entries
			unsecZone = entry.valueBetween("<b>", "</b>")
			if (not unsecZone) then continue

      print("Overflowing address <$>, unsecZone <$>, optArgs <$>".f(address, unsecZone, optArgs))
			data = metaLib.overflow(address, unsecZone, optArgs)
			print("====================")

			if (not ["computer", "shell", "file"].has(typeof(data))) then continue

			extra = (entry.LF).valuesBetween("* ", Std.LF)
			breach = Breach.New(data, address, unsecZone, extra)
			self.all.push(breach)
		end for
	end for
	self.withAction = self.all.filter(Std.Filters.byTruthyProp("action"))
	self.withShell = self.all.filter(Std.Filters.byTruthyProp("shell"))
	self.withXFile = self.all.filter(Std.Filters.byTruthyProp("xfile"))
end function

/*
  Scans and exploits a remote library.

  @param {RemoteLib} remoteLib - Remote library object with metaLib and optArgs
  @param {string} optArgs - Optional LAN IP override
 */
Breachs.scanAndExploit = function (remoteLib, optArgs = "")
	if (not remoteLib or not remoteLib.metaLib) then
		print("Error: Invalid remote library")
		return
	end if
	self._processScanResults(remoteLib.metaLib, optArgs)
end function

/*
  Scans and exploits a local library.

  @param {metaLib} metaLib - Library to exploit
  @param {string} optArgs - LAN IP address
 */
Breachs.scanAndExploitLocal = function (metaLib, optArgs = "")
	if (not metaLib) then
		print("Error: Invalid library")
		return
	end if
	self._processScanResults(metaLib, optArgs)
end function

module.exports = Breachs
