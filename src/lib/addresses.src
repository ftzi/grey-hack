#import Csv from "csv"

Adrs = {}
Addresses._addresses = null
Addresses._filePath = "/root/data/addresses.csv"

/*
  Loads saved addresses from the CSV file.

  @return {map}
 */
Addresses._loadSaved = function ()
    addresses = Csv.read(Addresses._filePath)
    if not addresses then
        print("Couldn't find any saved addresses.")
        return {}
    end if
    obj = {}
    for address in addresses
        libName_version = address["libName@version"].split("@")
        obj.set([libName_version[0], libName_version[1]], address.addresses[1:-1].split(","))
    end for
    return obj
end function

/*
  Returns the cached addresses, loading from file if not yet loaded.

  @return {map}
 */
Addresses.addresses = function ()
    if (Addresses._addresses == null) then Addresses._addresses = Addresses._loadSaved()
    return Addresses._addresses
end function

/*
  Checks if local addresses exist for a given library and version.

  @param {map|string} libOrLibName - A library object or library name string
  @param {string} version - The library version (used if libOrLibName is a string)
  @return {boolean}
 */
Addresses.hasLocalAddressesFor = function (libOrLibName, version)
    libName = libOrLibName
    version = version
    if (libOrLibName isa map) then
        libName = libOrLibName.lib_name
        version = libOrLibName.version
    end if
    return Addresses.addresses.get([libName, version]) != null
end function

/*
  Scans a library for addresses using Metaxploit and saves them to the CSV file.

  @param {map} lib - The library object to scan
  @return {list}
 */
Addresses.scan = function (lib)
    print("Scanning Addresses for <b>$ $</b> using Metaxploit $.".f(lib.lib_name, lib.version, Lib.versionOf("metaxploit")))
    addresses = Lib.metaxploit.scan(lib)
    print("Adding new addresses for $ $ to $".f(lib.lib_name, lib.version, Addresses._filePath))
    data = {"libName@version": lib.lib_name + "@" + lib.version, "addresses": addresses.toString}
    Csv.writeOrdered(Addresses._filePath, ["libName@version", "addresses"], data)
    Addresses.addresses.set([lib.lib_name, lib.version], addresses)
    return addresses
end function

/*
  Gets addresses for a library, scanning if not already cached.

  @param {map|string} libOrLibName - A library object or library name string
  @param {string} version - The library version (used if libOrLibName is a string)
  @return {list}
 */
Addresses.addressesFor = function (libOrLibName, version)
    libName = libOrLibName
    version = version
    if (libOrLibName isa map) then
        libName = libOrLibName.lib_name
        version = libOrLibName.version
    end if

    addresses = Addresses.addresses.get([libName, version])
    if (not addresses) then addresses = Addresses.scan(libOrLibName)

    return addresses
end function

module.exports = Adrs
