// This intentionally has no imports, so no file needs to be built before building this.

Compile = {}
Compile.accessed = []
Compile.compiled = []
Compile.optionToSkip = "--skipSelfCompile"

// @return {string} path of the executable entry file
Compile.compile = function (entryFilePath)
    if (entryFilePath[0] != "/") then entryFilePath = current_path + "/" + entryFilePath

    valuesBetween = function (string, open, close)
        array = []
        head = null
        tail = null
        while true
            head = string.indexOf(open, tail)
            if (head == null) then break
            tail = string.indexOf(close, head + open.len)
            if (tail == null) then break
            array.push(string[head + open.len:tail])
        end while

        return array
    end function

    recursive = function(filePath)
        if (filePath.indexOf(".src") == null) then filePath = filePath + ".src"

        // Skip this file if already accessed
        if (Compile.accessed.indexOf(filePath) != null) then return

        Compile.accessed.push(filePath)

        file = get_shell.host_computer.File(filePath)
        if (not file) then exit("<color=red>File not found: " + filePath + "</color>")

        fileContent = file.get_content()
        if (fileContent == null) then exit("<color=red>Coulnd't read the file " + file.path + "</color>")

        imports = valuesBetween(fileContent, "import_" + "code(""", """")

        for import in imports
            // We don't need to compile ".src" imports. Skip them!
            if (import.indexOf(".src") != null) then continue
            recursive(import)
        end for

        allowImport = filePath != entryFilePath
        buildResult = get_shell.build(file.path, file.parent.path, allowImport)
        Compile.compiled.push(file.path)
        if (buildResult) then
            exit("<color=red>Error building the file "+file.path+": " + buildResult+"</color>")
        end if
        return file.path.remove(".src")
    end function

    executablePath = recursive(entryFilePath)
    Compile.runTests()
    return executablePath
end function

// Makes the program build itself with the latest .src, if available, to improve DX.
// Passing --skipSelfCompile while calling the program skips this.
// This file should be imported first and this function should be called right after it.
Compile.selfCompile = function ()
    srcPath = program_path+".src"

    // Skip self compile if there is no source file for the entry file.
    if (get_shell.host_computer.File(srcPath) == null) then return

    indexOfSkip = params.indexOf(Compile.optionToSkip)
    // Skip if the optionToSkip is passed.
	if (indexOfSkip != null) then
        params.remove(indexOfSkip) // So it's not present in the final program if -x.
        return
    end if

	Compile.compile(srcPath)

    // Relaunch
	get_shell.launch(program_path, params.join(" ") + " " + Compile.optionToSkip)
	exit() // So the rest of the original program isn't run.
end function

Compile._main = function ()
    if (params.len > 0 and params[0] == "-h") then exit("<b>Usage:c [-x] [entryFile] [programArgs]</b>\n-x executes the file after compiling. If entry file is omitted, compiles the whole cwd.")

    compileAllFilesInDir = params.len == 0
    if (compileAllFilesInDir) then
        files = get_shell.host_computer.File(current_path).get_files
        for file in files
            Compile.compile(file.path)
        end for
        print("Successfully compiled "+files.len+" in the current directory.")
        return
    end if

    executeAfter = params[0] == "-x"
    if (executeAfter) then params.remove(0)

    entryFile = params[0]
    params.remove(0)

    executablePath = Compile.compile(entryFile)

    if (executeAfter) then get_shell.launch(executablePath, params.join(" "))
end function

// Run the tests, if any. NOTE:
Compile.runTests = function ()
    if (not globals.hasIndex("Test")) then return

    globals.Test.run()
end function

if (program_path.split("/")[-1] == "c") then
    Compile.selfCompile()
    Compile._main()
end if
